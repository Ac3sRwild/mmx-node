
// AUTO GENERATED by vnxcppcodegen

#include <mmx/contract/Data.hxx>
#include <mmx/contract/Data_calc_cost.hxx>
#include <mmx/contract/Data_calc_cost_return.hxx>
#include <mmx/contract/Data_calc_hash.hxx>
#include <mmx/contract/Data_calc_hash_return.hxx>
#include <mmx/contract/Locked.hxx>
#include <mmx/contract/Locked_calc_cost.hxx>
#include <mmx/contract/Locked_calc_cost_return.hxx>
#include <mmx/contract/Locked_calc_hash.hxx>
#include <mmx/contract/Locked_calc_hash_return.hxx>
#include <mmx/contract/Locked_get_dependency.hxx>
#include <mmx/contract/Locked_get_dependency_return.hxx>
#include <mmx/contract/Locked_get_owner.hxx>
#include <mmx/contract/Locked_get_owner_return.hxx>
#include <mmx/contract/Locked_get_parties.hxx>
#include <mmx/contract/Locked_get_parties_return.hxx>
#include <mmx/contract/Locked_is_spendable.hxx>
#include <mmx/contract/Locked_is_spendable_return.hxx>
#include <mmx/contract/Locked_is_valid.hxx>
#include <mmx/contract/Locked_is_valid_return.hxx>
#include <mmx/contract/Locked_validate.hxx>
#include <mmx/contract/Locked_validate_return.hxx>
#include <mmx/contract/MultiSig.hxx>
#include <mmx/contract/MultiSig_add_owner.hxx>
#include <mmx/contract/MultiSig_add_owner_return.hxx>
#include <mmx/contract/MultiSig_calc_cost.hxx>
#include <mmx/contract/MultiSig_calc_cost_return.hxx>
#include <mmx/contract/MultiSig_calc_hash.hxx>
#include <mmx/contract/MultiSig_calc_hash_return.hxx>
#include <mmx/contract/MultiSig_get_dependency.hxx>
#include <mmx/contract/MultiSig_get_dependency_return.hxx>
#include <mmx/contract/MultiSig_get_parties.hxx>
#include <mmx/contract/MultiSig_get_parties_return.hxx>
#include <mmx/contract/MultiSig_is_valid.hxx>
#include <mmx/contract/MultiSig_is_valid_return.hxx>
#include <mmx/contract/MultiSig_rem_owner.hxx>
#include <mmx/contract/MultiSig_rem_owner_return.hxx>
#include <mmx/contract/MultiSig_validate.hxx>
#include <mmx/contract/MultiSig_validate_return.hxx>
#include <mmx/contract/NFT.hxx>
#include <mmx/contract/NFT_calc_cost.hxx>
#include <mmx/contract/NFT_calc_cost_return.hxx>
#include <mmx/contract/NFT_calc_hash.hxx>
#include <mmx/contract/NFT_calc_hash_return.hxx>
#include <mmx/contract/NFT_is_valid.hxx>
#include <mmx/contract/NFT_is_valid_return.hxx>
#include <mmx/contract/PubKey.hxx>
#include <mmx/contract/PubKey_calc_cost.hxx>
#include <mmx/contract/PubKey_calc_cost_return.hxx>
#include <mmx/contract/PubKey_calc_hash.hxx>
#include <mmx/contract/PubKey_calc_hash_return.hxx>
#include <mmx/contract/PubKey_get_dependency.hxx>
#include <mmx/contract/PubKey_get_dependency_return.hxx>
#include <mmx/contract/PubKey_get_owner.hxx>
#include <mmx/contract/PubKey_get_owner_return.hxx>
#include <mmx/contract/PubKey_get_parties.hxx>
#include <mmx/contract/PubKey_get_parties_return.hxx>
#include <mmx/contract/PubKey_is_valid.hxx>
#include <mmx/contract/PubKey_is_valid_return.hxx>
#include <mmx/contract/PubKey_validate.hxx>
#include <mmx/contract/PubKey_validate_return.hxx>
#include <mmx/contract/PuzzleLock.hxx>
#include <mmx/contract/PuzzleLock_calc_cost.hxx>
#include <mmx/contract/PuzzleLock_calc_cost_return.hxx>
#include <mmx/contract/PuzzleLock_calc_hash.hxx>
#include <mmx/contract/PuzzleLock_calc_hash_return.hxx>
#include <mmx/contract/PuzzleLock_get_parties.hxx>
#include <mmx/contract/PuzzleLock_get_parties_return.hxx>
#include <mmx/contract/PuzzleLock_is_valid.hxx>
#include <mmx/contract/PuzzleLock_is_valid_return.hxx>
#include <mmx/contract/PuzzleLock_validate.hxx>
#include <mmx/contract/PuzzleLock_validate_return.hxx>
#include <mmx/contract/Staking.hxx>
#include <mmx/contract/Staking_calc_cost.hxx>
#include <mmx/contract/Staking_calc_cost_return.hxx>
#include <mmx/contract/Staking_calc_hash.hxx>
#include <mmx/contract/Staking_calc_hash_return.hxx>
#include <mmx/contract/Staking_get_dependency.hxx>
#include <mmx/contract/Staking_get_dependency_return.hxx>
#include <mmx/contract/Staking_get_owner.hxx>
#include <mmx/contract/Staking_get_owner_return.hxx>
#include <mmx/contract/Staking_get_parties.hxx>
#include <mmx/contract/Staking_get_parties_return.hxx>
#include <mmx/contract/Staking_is_valid.hxx>
#include <mmx/contract/Staking_is_valid_return.hxx>
#include <mmx/contract/Staking_validate.hxx>
#include <mmx/contract/Staking_validate_return.hxx>
#include <mmx/contract/Token.hxx>
#include <mmx/contract/Token_calc_cost.hxx>
#include <mmx/contract/Token_calc_cost_return.hxx>
#include <mmx/contract/Token_calc_hash.hxx>
#include <mmx/contract/Token_calc_hash_return.hxx>
#include <mmx/contract/Token_get_dependency.hxx>
#include <mmx/contract/Token_get_dependency_return.hxx>
#include <mmx/contract/Token_get_owner.hxx>
#include <mmx/contract/Token_get_owner_return.hxx>
#include <mmx/contract/Token_get_parties.hxx>
#include <mmx/contract/Token_get_parties_return.hxx>
#include <mmx/contract/Token_is_valid.hxx>
#include <mmx/contract/Token_is_valid_return.hxx>
#include <mmx/contract/Token_transfer.hxx>
#include <mmx/contract/Token_transfer_return.hxx>
#include <mmx/contract/Token_validate.hxx>
#include <mmx/contract/Token_validate_return.hxx>
#include <mmx/contract/WebData.hxx>
#include <mmx/contract/WebData_calc_cost.hxx>
#include <mmx/contract/WebData_calc_cost_return.hxx>
#include <mmx/contract/WebData_calc_hash.hxx>
#include <mmx/contract/WebData_calc_hash_return.hxx>
#include <mmx/contract/WebData_is_valid.hxx>
#include <mmx/contract/WebData_is_valid_return.hxx>
#include <mmx/contract/compare_e.hxx>
#include <mmx/contract/condition_e.hxx>

#include <mmx/contract/package.hxx>
#include <vnx/vnx.h>



namespace vnx {

const TypeCode* type<::mmx::contract::Data>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Data;
}

void type<::mmx::contract::Data>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Data());
}

void type<::mmx::contract::Data>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Data& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Data_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Data_calc_cost;
}

void type<::mmx::contract::Data_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Data_calc_cost());
}

void type<::mmx::contract::Data_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Data_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Data_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Data_calc_cost_return;
}

void type<::mmx::contract::Data_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Data_calc_cost_return());
}

void type<::mmx::contract::Data_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Data_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Data_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Data_calc_hash;
}

void type<::mmx::contract::Data_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Data_calc_hash());
}

void type<::mmx::contract::Data_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Data_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Data_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Data_calc_hash_return;
}

void type<::mmx::contract::Data_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Data_calc_hash_return());
}

void type<::mmx::contract::Data_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Data_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked;
}

void type<::mmx::contract::Locked>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked());
}

void type<::mmx::contract::Locked>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_calc_cost;
}

void type<::mmx::contract::Locked_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_calc_cost());
}

void type<::mmx::contract::Locked_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_calc_cost_return;
}

void type<::mmx::contract::Locked_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_calc_cost_return());
}

void type<::mmx::contract::Locked_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_calc_hash;
}

void type<::mmx::contract::Locked_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_calc_hash());
}

void type<::mmx::contract::Locked_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_calc_hash_return;
}

void type<::mmx::contract::Locked_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_calc_hash_return());
}

void type<::mmx::contract::Locked_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_get_dependency>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_get_dependency;
}

void type<::mmx::contract::Locked_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_get_dependency());
}

void type<::mmx::contract::Locked_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_get_dependency& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_get_dependency_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_get_dependency_return;
}

void type<::mmx::contract::Locked_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_get_dependency_return());
}

void type<::mmx::contract::Locked_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_get_dependency_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_get_owner>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_get_owner;
}

void type<::mmx::contract::Locked_get_owner>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_get_owner());
}

void type<::mmx::contract::Locked_get_owner>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_get_owner& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_get_owner_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_get_owner_return;
}

void type<::mmx::contract::Locked_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_get_owner_return());
}

void type<::mmx::contract::Locked_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_get_owner_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_get_parties>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_get_parties;
}

void type<::mmx::contract::Locked_get_parties>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_get_parties());
}

void type<::mmx::contract::Locked_get_parties>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_get_parties& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_get_parties_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_get_parties_return;
}

void type<::mmx::contract::Locked_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_get_parties_return());
}

void type<::mmx::contract::Locked_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_get_parties_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_is_spendable>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_is_spendable;
}

void type<::mmx::contract::Locked_is_spendable>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_is_spendable());
}

void type<::mmx::contract::Locked_is_spendable>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_is_spendable& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_is_spendable_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_is_spendable_return;
}

void type<::mmx::contract::Locked_is_spendable_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_is_spendable_return());
}

void type<::mmx::contract::Locked_is_spendable_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_is_spendable_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_is_valid;
}

void type<::mmx::contract::Locked_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_is_valid());
}

void type<::mmx::contract::Locked_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_is_valid_return;
}

void type<::mmx::contract::Locked_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_is_valid_return());
}

void type<::mmx::contract::Locked_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_validate>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_validate;
}

void type<::mmx::contract::Locked_validate>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_validate());
}

void type<::mmx::contract::Locked_validate>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_validate& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Locked_validate_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Locked_validate_return;
}

void type<::mmx::contract::Locked_validate_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Locked_validate_return());
}

void type<::mmx::contract::Locked_validate_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Locked_validate_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig;
}

void type<::mmx::contract::MultiSig>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig());
}

void type<::mmx::contract::MultiSig>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_add_owner>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_add_owner;
}

void type<::mmx::contract::MultiSig_add_owner>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_add_owner());
}

void type<::mmx::contract::MultiSig_add_owner>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_add_owner& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_add_owner_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_add_owner_return;
}

void type<::mmx::contract::MultiSig_add_owner_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_add_owner_return());
}

void type<::mmx::contract::MultiSig_add_owner_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_add_owner_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_calc_cost;
}

void type<::mmx::contract::MultiSig_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_calc_cost());
}

void type<::mmx::contract::MultiSig_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_calc_cost_return;
}

void type<::mmx::contract::MultiSig_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_calc_cost_return());
}

void type<::mmx::contract::MultiSig_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_calc_hash;
}

void type<::mmx::contract::MultiSig_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_calc_hash());
}

void type<::mmx::contract::MultiSig_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_calc_hash_return;
}

void type<::mmx::contract::MultiSig_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_calc_hash_return());
}

void type<::mmx::contract::MultiSig_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_get_dependency>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_get_dependency;
}

void type<::mmx::contract::MultiSig_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_get_dependency());
}

void type<::mmx::contract::MultiSig_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_get_dependency& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_get_dependency_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_get_dependency_return;
}

void type<::mmx::contract::MultiSig_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_get_dependency_return());
}

void type<::mmx::contract::MultiSig_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_get_dependency_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_get_parties>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_get_parties;
}

void type<::mmx::contract::MultiSig_get_parties>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_get_parties());
}

void type<::mmx::contract::MultiSig_get_parties>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_get_parties& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_get_parties_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_get_parties_return;
}

void type<::mmx::contract::MultiSig_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_get_parties_return());
}

void type<::mmx::contract::MultiSig_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_get_parties_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_is_valid;
}

void type<::mmx::contract::MultiSig_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_is_valid());
}

void type<::mmx::contract::MultiSig_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_is_valid_return;
}

void type<::mmx::contract::MultiSig_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_is_valid_return());
}

void type<::mmx::contract::MultiSig_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_rem_owner>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_rem_owner;
}

void type<::mmx::contract::MultiSig_rem_owner>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_rem_owner());
}

void type<::mmx::contract::MultiSig_rem_owner>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_rem_owner& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_rem_owner_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_rem_owner_return;
}

void type<::mmx::contract::MultiSig_rem_owner_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_rem_owner_return());
}

void type<::mmx::contract::MultiSig_rem_owner_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_rem_owner_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_validate>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_validate;
}

void type<::mmx::contract::MultiSig_validate>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_validate());
}

void type<::mmx::contract::MultiSig_validate>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_validate& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig_validate_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig_validate_return;
}

void type<::mmx::contract::MultiSig_validate_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig_validate_return());
}

void type<::mmx::contract::MultiSig_validate_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig_validate_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT;
}

void type<::mmx::contract::NFT>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT());
}

void type<::mmx::contract::NFT>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT_calc_cost;
}

void type<::mmx::contract::NFT_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT_calc_cost());
}

void type<::mmx::contract::NFT_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT_calc_cost_return;
}

void type<::mmx::contract::NFT_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT_calc_cost_return());
}

void type<::mmx::contract::NFT_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT_calc_hash;
}

void type<::mmx::contract::NFT_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT_calc_hash());
}

void type<::mmx::contract::NFT_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT_calc_hash_return;
}

void type<::mmx::contract::NFT_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT_calc_hash_return());
}

void type<::mmx::contract::NFT_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT_is_valid;
}

void type<::mmx::contract::NFT_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT_is_valid());
}

void type<::mmx::contract::NFT_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::NFT_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_NFT_is_valid_return;
}

void type<::mmx::contract::NFT_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::NFT_is_valid_return());
}

void type<::mmx::contract::NFT_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::NFT_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey;
}

void type<::mmx::contract::PubKey>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey());
}

void type<::mmx::contract::PubKey>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_calc_cost;
}

void type<::mmx::contract::PubKey_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_calc_cost());
}

void type<::mmx::contract::PubKey_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_calc_cost_return;
}

void type<::mmx::contract::PubKey_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_calc_cost_return());
}

void type<::mmx::contract::PubKey_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_calc_hash;
}

void type<::mmx::contract::PubKey_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_calc_hash());
}

void type<::mmx::contract::PubKey_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_calc_hash_return;
}

void type<::mmx::contract::PubKey_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_calc_hash_return());
}

void type<::mmx::contract::PubKey_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_get_dependency>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_get_dependency;
}

void type<::mmx::contract::PubKey_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_get_dependency());
}

void type<::mmx::contract::PubKey_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_get_dependency& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_get_dependency_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_get_dependency_return;
}

void type<::mmx::contract::PubKey_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_get_dependency_return());
}

void type<::mmx::contract::PubKey_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_get_dependency_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_get_owner>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_get_owner;
}

void type<::mmx::contract::PubKey_get_owner>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_get_owner());
}

void type<::mmx::contract::PubKey_get_owner>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_get_owner& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_get_owner_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_get_owner_return;
}

void type<::mmx::contract::PubKey_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_get_owner_return());
}

void type<::mmx::contract::PubKey_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_get_owner_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_get_parties>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_get_parties;
}

void type<::mmx::contract::PubKey_get_parties>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_get_parties());
}

void type<::mmx::contract::PubKey_get_parties>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_get_parties& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_get_parties_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_get_parties_return;
}

void type<::mmx::contract::PubKey_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_get_parties_return());
}

void type<::mmx::contract::PubKey_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_get_parties_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_is_valid;
}

void type<::mmx::contract::PubKey_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_is_valid());
}

void type<::mmx::contract::PubKey_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_is_valid_return;
}

void type<::mmx::contract::PubKey_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_is_valid_return());
}

void type<::mmx::contract::PubKey_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_validate>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_validate;
}

void type<::mmx::contract::PubKey_validate>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_validate());
}

void type<::mmx::contract::PubKey_validate>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_validate& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey_validate_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey_validate_return;
}

void type<::mmx::contract::PubKey_validate_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey_validate_return());
}

void type<::mmx::contract::PubKey_validate_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey_validate_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock;
}

void type<::mmx::contract::PuzzleLock>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock());
}

void type<::mmx::contract::PuzzleLock>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_calc_cost;
}

void type<::mmx::contract::PuzzleLock_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_calc_cost());
}

void type<::mmx::contract::PuzzleLock_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_calc_cost_return;
}

void type<::mmx::contract::PuzzleLock_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_calc_cost_return());
}

void type<::mmx::contract::PuzzleLock_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_calc_hash;
}

void type<::mmx::contract::PuzzleLock_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_calc_hash());
}

void type<::mmx::contract::PuzzleLock_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_calc_hash_return;
}

void type<::mmx::contract::PuzzleLock_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_calc_hash_return());
}

void type<::mmx::contract::PuzzleLock_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_get_parties>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_get_parties;
}

void type<::mmx::contract::PuzzleLock_get_parties>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_get_parties());
}

void type<::mmx::contract::PuzzleLock_get_parties>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_get_parties& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_get_parties_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_get_parties_return;
}

void type<::mmx::contract::PuzzleLock_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_get_parties_return());
}

void type<::mmx::contract::PuzzleLock_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_get_parties_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_is_valid;
}

void type<::mmx::contract::PuzzleLock_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_is_valid());
}

void type<::mmx::contract::PuzzleLock_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_is_valid_return;
}

void type<::mmx::contract::PuzzleLock_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_is_valid_return());
}

void type<::mmx::contract::PuzzleLock_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_validate>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_validate;
}

void type<::mmx::contract::PuzzleLock_validate>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_validate());
}

void type<::mmx::contract::PuzzleLock_validate>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_validate& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PuzzleLock_validate_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PuzzleLock_validate_return;
}

void type<::mmx::contract::PuzzleLock_validate_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PuzzleLock_validate_return());
}

void type<::mmx::contract::PuzzleLock_validate_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PuzzleLock_validate_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking;
}

void type<::mmx::contract::Staking>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking());
}

void type<::mmx::contract::Staking>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_calc_cost;
}

void type<::mmx::contract::Staking_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_calc_cost());
}

void type<::mmx::contract::Staking_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_calc_cost_return;
}

void type<::mmx::contract::Staking_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_calc_cost_return());
}

void type<::mmx::contract::Staking_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_calc_hash;
}

void type<::mmx::contract::Staking_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_calc_hash());
}

void type<::mmx::contract::Staking_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_calc_hash_return;
}

void type<::mmx::contract::Staking_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_calc_hash_return());
}

void type<::mmx::contract::Staking_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_get_dependency>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_get_dependency;
}

void type<::mmx::contract::Staking_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_get_dependency());
}

void type<::mmx::contract::Staking_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_get_dependency& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_get_dependency_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_get_dependency_return;
}

void type<::mmx::contract::Staking_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_get_dependency_return());
}

void type<::mmx::contract::Staking_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_get_dependency_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_get_owner>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_get_owner;
}

void type<::mmx::contract::Staking_get_owner>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_get_owner());
}

void type<::mmx::contract::Staking_get_owner>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_get_owner& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_get_owner_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_get_owner_return;
}

void type<::mmx::contract::Staking_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_get_owner_return());
}

void type<::mmx::contract::Staking_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_get_owner_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_get_parties>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_get_parties;
}

void type<::mmx::contract::Staking_get_parties>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_get_parties());
}

void type<::mmx::contract::Staking_get_parties>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_get_parties& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_get_parties_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_get_parties_return;
}

void type<::mmx::contract::Staking_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_get_parties_return());
}

void type<::mmx::contract::Staking_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_get_parties_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_is_valid;
}

void type<::mmx::contract::Staking_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_is_valid());
}

void type<::mmx::contract::Staking_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_is_valid_return;
}

void type<::mmx::contract::Staking_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_is_valid_return());
}

void type<::mmx::contract::Staking_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_validate>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_validate;
}

void type<::mmx::contract::Staking_validate>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_validate());
}

void type<::mmx::contract::Staking_validate>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_validate& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Staking_validate_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Staking_validate_return;
}

void type<::mmx::contract::Staking_validate_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Staking_validate_return());
}

void type<::mmx::contract::Staking_validate_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Staking_validate_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token;
}

void type<::mmx::contract::Token>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token());
}

void type<::mmx::contract::Token>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_calc_cost;
}

void type<::mmx::contract::Token_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_calc_cost());
}

void type<::mmx::contract::Token_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_calc_cost_return;
}

void type<::mmx::contract::Token_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_calc_cost_return());
}

void type<::mmx::contract::Token_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_calc_hash;
}

void type<::mmx::contract::Token_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_calc_hash());
}

void type<::mmx::contract::Token_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_calc_hash_return;
}

void type<::mmx::contract::Token_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_calc_hash_return());
}

void type<::mmx::contract::Token_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_get_dependency>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_get_dependency;
}

void type<::mmx::contract::Token_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_get_dependency());
}

void type<::mmx::contract::Token_get_dependency>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_get_dependency& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_get_dependency_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_get_dependency_return;
}

void type<::mmx::contract::Token_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_get_dependency_return());
}

void type<::mmx::contract::Token_get_dependency_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_get_dependency_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_get_owner>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_get_owner;
}

void type<::mmx::contract::Token_get_owner>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_get_owner());
}

void type<::mmx::contract::Token_get_owner>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_get_owner& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_get_owner_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_get_owner_return;
}

void type<::mmx::contract::Token_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_get_owner_return());
}

void type<::mmx::contract::Token_get_owner_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_get_owner_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_get_parties>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_get_parties;
}

void type<::mmx::contract::Token_get_parties>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_get_parties());
}

void type<::mmx::contract::Token_get_parties>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_get_parties& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_get_parties_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_get_parties_return;
}

void type<::mmx::contract::Token_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_get_parties_return());
}

void type<::mmx::contract::Token_get_parties_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_get_parties_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_is_valid;
}

void type<::mmx::contract::Token_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_is_valid());
}

void type<::mmx::contract::Token_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_is_valid_return;
}

void type<::mmx::contract::Token_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_is_valid_return());
}

void type<::mmx::contract::Token_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_transfer>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_transfer;
}

void type<::mmx::contract::Token_transfer>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_transfer());
}

void type<::mmx::contract::Token_transfer>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_transfer& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_transfer_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_transfer_return;
}

void type<::mmx::contract::Token_transfer_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_transfer_return());
}

void type<::mmx::contract::Token_transfer_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_transfer_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_validate>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_validate;
}

void type<::mmx::contract::Token_validate>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_validate());
}

void type<::mmx::contract::Token_validate>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_validate& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Token_validate_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Token_validate_return;
}

void type<::mmx::contract::Token_validate_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Token_validate_return());
}

void type<::mmx::contract::Token_validate_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Token_validate_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData;
}

void type<::mmx::contract::WebData>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData());
}

void type<::mmx::contract::WebData>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData_calc_cost>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData_calc_cost;
}

void type<::mmx::contract::WebData_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData_calc_cost());
}

void type<::mmx::contract::WebData_calc_cost>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData_calc_cost& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData_calc_cost_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData_calc_cost_return;
}

void type<::mmx::contract::WebData_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData_calc_cost_return());
}

void type<::mmx::contract::WebData_calc_cost_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData_calc_cost_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData_calc_hash>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData_calc_hash;
}

void type<::mmx::contract::WebData_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData_calc_hash());
}

void type<::mmx::contract::WebData_calc_hash>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData_calc_hash& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData_calc_hash_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData_calc_hash_return;
}

void type<::mmx::contract::WebData_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData_calc_hash_return());
}

void type<::mmx::contract::WebData_calc_hash_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData_calc_hash_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData_is_valid>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData_is_valid;
}

void type<::mmx::contract::WebData_is_valid>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData_is_valid());
}

void type<::mmx::contract::WebData_is_valid>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData_is_valid& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData_is_valid_return>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData_is_valid_return;
}

void type<::mmx::contract::WebData_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData_is_valid_return());
}

void type<::mmx::contract::WebData_is_valid_return>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData_is_valid_return& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::compare_e>::get_type_code() {
	return mmx::contract::vnx_native_type_code_compare_e;
}

void type<::mmx::contract::compare_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::compare_e());
}

void type<::mmx::contract::compare_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::compare_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}

const TypeCode* type<::mmx::contract::condition_e>::get_type_code() {
	return mmx::contract::vnx_native_type_code_condition_e;
}

void type<::mmx::contract::condition_e>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::condition_e());
}

void type<::mmx::contract::condition_e>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::condition_e& value, bool special) {
	if(!special || value.is_valid()) {
		code.push_back(CODE_STRING);
	} else {
		code.push_back(CODE_UINT32);
	}
}


} // namespace vnx


namespace mmx {
namespace contract {


static void register_all_types() {
	vnx::register_type_code(::mmx::contract::Data::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Data_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Data_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Data_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Data_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_get_dependency::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_get_dependency_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_get_owner::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_get_owner_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_get_parties::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_get_parties_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_is_spendable::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_is_spendable_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_validate::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Locked_validate_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_add_owner::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_add_owner_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_get_dependency::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_get_dependency_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_get_parties::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_get_parties_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_rem_owner::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_rem_owner_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_validate::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig_validate_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::NFT_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_get_dependency::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_get_dependency_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_get_owner::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_get_owner_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_get_parties::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_get_parties_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_validate::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey_validate_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_get_parties::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_get_parties_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_validate::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PuzzleLock_validate_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_get_dependency::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_get_dependency_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_get_owner::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_get_owner_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_get_parties::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_get_parties_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_validate::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Staking_validate_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_get_dependency::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_get_dependency_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_get_owner::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_get_owner_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_get_parties::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_get_parties_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_transfer::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_transfer_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_validate::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Token_validate_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData_calc_cost::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData_calc_cost_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData_calc_hash::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData_calc_hash_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData_is_valid::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData_is_valid_return::static_create_type_code());
	vnx::register_type_code(::mmx::contract::compare_e::static_create_type_code());
	vnx::register_type_code(::mmx::contract::condition_e::static_create_type_code());
}

static struct vnx_static_init {
	vnx_static_init() {
		register_all_types();
	}
} vnx_static_init_;

const vnx::TypeCode* const vnx_native_type_code_Data = vnx::get_type_code(vnx::Hash64(0xadfeee3822244f50ull));
const vnx::TypeCode* const vnx_native_type_code_Data_calc_cost = vnx::get_type_code(vnx::Hash64(0xd330303ae8af8a8bull));
const vnx::TypeCode* const vnx_native_type_code_Data_calc_cost_return = vnx::get_type_code(vnx::Hash64(0xffa8c93868ea4352ull));
const vnx::TypeCode* const vnx_native_type_code_Data_calc_hash = vnx::get_type_code(vnx::Hash64(0x322fb5c8d3dfe74ull));
const vnx::TypeCode* const vnx_native_type_code_Data_calc_hash_return = vnx::get_type_code(vnx::Hash64(0x84fe9434ee352e2eull));
const vnx::TypeCode* const vnx_native_type_code_Locked = vnx::get_type_code(vnx::Hash64(0xd0ff1b6e7bad1493ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_calc_cost = vnx::get_type_code(vnx::Hash64(0x4d220deaf420a61aull));
const vnx::TypeCode* const vnx_native_type_code_Locked_calc_cost_return = vnx::get_type_code(vnx::Hash64(0x4ef0016844aa601full));
const vnx::TypeCode* const vnx_native_type_code_Locked_calc_hash = vnx::get_type_code(vnx::Hash64(0x9d30c68c91b2d2e5ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_calc_hash_return = vnx::get_type_code(vnx::Hash64(0x35a65c64c2750d63ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_get_dependency = vnx::get_type_code(vnx::Hash64(0xf155dff11fe1aed3ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_get_dependency_return = vnx::get_type_code(vnx::Hash64(0xe918f484aa2ae261ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_get_owner = vnx::get_type_code(vnx::Hash64(0x70fdcfdff7248688ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_get_owner_return = vnx::get_type_code(vnx::Hash64(0x4d3bf1b4a1d98e97ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_get_parties = vnx::get_type_code(vnx::Hash64(0xb634d38d89230559ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_get_parties_return = vnx::get_type_code(vnx::Hash64(0x8a824e2ac3637512ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_is_spendable = vnx::get_type_code(vnx::Hash64(0xa904459ea0b4fdddull));
const vnx::TypeCode* const vnx_native_type_code_Locked_is_spendable_return = vnx::get_type_code(vnx::Hash64(0x19d6a2814597bd97ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_is_valid = vnx::get_type_code(vnx::Hash64(0x37ed54e91a14f1acull));
const vnx::TypeCode* const vnx_native_type_code_Locked_is_valid_return = vnx::get_type_code(vnx::Hash64(0xba9468890cf05961ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_validate = vnx::get_type_code(vnx::Hash64(0x1652c71f107a4ee9ull));
const vnx::TypeCode* const vnx_native_type_code_Locked_validate_return = vnx::get_type_code(vnx::Hash64(0xa7b1d458c00fc89aull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig = vnx::get_type_code(vnx::Hash64(0x7d674c5f7297dedull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_add_owner = vnx::get_type_code(vnx::Hash64(0xaa2e4c882b71dd83ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_add_owner_return = vnx::get_type_code(vnx::Hash64(0xff53ef68cb213c51ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_calc_cost = vnx::get_type_code(vnx::Hash64(0x1f65ef156660d39full));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_calc_cost_return = vnx::get_type_code(vnx::Hash64(0x27d3b356beac0b61ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_calc_hash = vnx::get_type_code(vnx::Hash64(0xcf77247303f2a760ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_calc_hash_return = vnx::get_type_code(vnx::Hash64(0x5c85ee5a3873661dull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_get_dependency = vnx::get_type_code(vnx::Hash64(0xd5b28a8ba1fda714ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_get_dependency_return = vnx::get_type_code(vnx::Hash64(0xc30bc595fa06fd8full));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_get_parties = vnx::get_type_code(vnx::Hash64(0x99bf8748d9ab3076ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_get_parties_return = vnx::get_type_code(vnx::Hash64(0x3c5857efd3a8b353ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_is_valid = vnx::get_type_code(vnx::Hash64(0x613ac937350f5cd7ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_is_valid_return = vnx::get_type_code(vnx::Hash64(0x2b104aee1e626c8cull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_rem_owner = vnx::get_type_code(vnx::Hash64(0x76c14727e0beab3cull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_rem_owner_return = vnx::get_type_code(vnx::Hash64(0xfa7d0d0c0718b8b1ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_validate = vnx::get_type_code(vnx::Hash64(0x40855ac13f61e392ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig_validate_return = vnx::get_type_code(vnx::Hash64(0x3635f63fd29dfd77ull));
const vnx::TypeCode* const vnx_native_type_code_NFT = vnx::get_type_code(vnx::Hash64(0x7cb24b9888a47906ull));
const vnx::TypeCode* const vnx_native_type_code_NFT_calc_cost = vnx::get_type_code(vnx::Hash64(0x462462234574232ull));
const vnx::TypeCode* const vnx_native_type_code_NFT_calc_cost_return = vnx::get_type_code(vnx::Hash64(0xcbb78b8c7318ffecull));
const vnx::TypeCode* const vnx_native_type_code_NFT_calc_hash = vnx::get_type_code(vnx::Hash64(0xd4708d4451c536cdull));
const vnx::TypeCode* const vnx_native_type_code_NFT_calc_hash_return = vnx::get_type_code(vnx::Hash64(0xb0e1d680f5c79290ull));
const vnx::TypeCode* const vnx_native_type_code_NFT_is_valid = vnx::get_type_code(vnx::Hash64(0xfc70fda3036d3a08ull));
const vnx::TypeCode* const vnx_native_type_code_NFT_is_valid_return = vnx::get_type_code(vnx::Hash64(0x744c9a1ab5d94c5bull));
const vnx::TypeCode* const vnx_native_type_code_PubKey = vnx::get_type_code(vnx::Hash64(0x9b3cd508d7f41423ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_calc_cost = vnx::get_type_code(vnx::Hash64(0x502d1edce44719b3ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_calc_cost_return = vnx::get_type_code(vnx::Hash64(0xc2f589dac0e8bcb0ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_calc_hash = vnx::get_type_code(vnx::Hash64(0x803fd5ba81d56d4cull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_calc_hash_return = vnx::get_type_code(vnx::Hash64(0xb9a3d4d64637d1ccull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_get_dependency = vnx::get_type_code(vnx::Hash64(0x5eddf8d7882958f5ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_get_dependency_return = vnx::get_type_code(vnx::Hash64(0x3870c96738844d0full));
const vnx::TypeCode* const vnx_native_type_code_PubKey_get_owner = vnx::get_type_code(vnx::Hash64(0x6df2dce9e7433921ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_get_owner_return = vnx::get_type_code(vnx::Hash64(0xc13e7906259b5238ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_get_parties = vnx::get_type_code(vnx::Hash64(0xa6978635d6f6f845ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_get_parties_return = vnx::get_type_code(vnx::Hash64(0x2aa5238d809c9087ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_is_valid = vnx::get_type_code(vnx::Hash64(0xe97fdd91c060e967ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_is_valid_return = vnx::get_type_code(vnx::Hash64(0xce58570ddfcea36dull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_validate = vnx::get_type_code(vnx::Hash64(0xc8c04e67ca0e5622ull));
const vnx::TypeCode* const vnx_native_type_code_PubKey_validate_return = vnx::get_type_code(vnx::Hash64(0xd37debdc13313296ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock = vnx::get_type_code(vnx::Hash64(0xf33097b29a62c755ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_calc_cost = vnx::get_type_code(vnx::Hash64(0xef887e5b77e465b5ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_calc_cost_return = vnx::get_type_code(vnx::Hash64(0xe3703fa5e9b25e67ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_calc_hash = vnx::get_type_code(vnx::Hash64(0x3f9ab53d1276114aull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_calc_hash_return = vnx::get_type_code(vnx::Hash64(0x982662a96f6d331bull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_get_parties = vnx::get_type_code(vnx::Hash64(0xa0530fd9cb9a9c62ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_get_parties_return = vnx::get_type_code(vnx::Hash64(0x85242cc27c6f3c52ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_is_valid = vnx::get_type_code(vnx::Hash64(0xf4969d5cbc33744eull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_is_valid_return = vnx::get_type_code(vnx::Hash64(0xe0d6fa185046c2a1ull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_validate = vnx::get_type_code(vnx::Hash64(0xd5290eaab65dcb0bull));
const vnx::TypeCode* const vnx_native_type_code_PuzzleLock_validate_return = vnx::get_type_code(vnx::Hash64(0xfdf346c99cb9535aull));
const vnx::TypeCode* const vnx_native_type_code_Staking = vnx::get_type_code(vnx::Hash64(0xf058a3326fc2e7dcull));
const vnx::TypeCode* const vnx_native_type_code_Staking_calc_cost = vnx::get_type_code(vnx::Hash64(0x2f4c65f2e7467929ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_calc_cost_return = vnx::get_type_code(vnx::Hash64(0x59e400e91ac41189ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_calc_hash = vnx::get_type_code(vnx::Hash64(0xff5eae9482d40dd6ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_calc_hash_return = vnx::get_type_code(vnx::Hash64(0x22b25de59c1b7cf5ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_get_dependency = vnx::get_type_code(vnx::Hash64(0x69fc4777b2a7af06ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_get_dependency_return = vnx::get_type_code(vnx::Hash64(0x78150da57ad63d50ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_get_owner = vnx::get_type_code(vnx::Hash64(0x1293a7c7e44259bbull));
const vnx::TypeCode* const vnx_native_type_code_Staking_get_owner_return = vnx::get_type_code(vnx::Hash64(0x5a2ff035ffb7ff01ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_get_parties = vnx::get_type_code(vnx::Hash64(0x30595432b3360eb1ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_get_parties_return = vnx::get_type_code(vnx::Hash64(0x3a66d52454096f9ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_is_valid = vnx::get_type_code(vnx::Hash64(0xa4cc3abf037419f8ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_is_valid_return = vnx::get_type_code(vnx::Hash64(0xa2b3934c1b02f096ull));
const vnx::TypeCode* const vnx_native_type_code_Staking_validate = vnx::get_type_code(vnx::Hash64(0x8573a949091aa6bdull));
const vnx::TypeCode* const vnx_native_type_code_Staking_validate_return = vnx::get_type_code(vnx::Hash64(0xbf962f9dd7fd616dull));
const vnx::TypeCode* const vnx_native_type_code_Token = vnx::get_type_code(vnx::Hash64(0x2d8835d6429431b2ull));
const vnx::TypeCode* const vnx_native_type_code_Token_calc_cost = vnx::get_type_code(vnx::Hash64(0xbf384ca6ba587f13ull));
const vnx::TypeCode* const vnx_native_type_code_Token_calc_cost_return = vnx::get_type_code(vnx::Hash64(0x7837720d0f1ee972ull));
const vnx::TypeCode* const vnx_native_type_code_Token_calc_hash = vnx::get_type_code(vnx::Hash64(0x6f2a87c0dfca0becull));
const vnx::TypeCode* const vnx_native_type_code_Token_calc_hash_return = vnx::get_type_code(vnx::Hash64(0x3612f0189c1840eull));
const vnx::TypeCode* const vnx_native_type_code_Token_get_dependency = vnx::get_type_code(vnx::Hash64(0xd6b8b4d0f1a86d08ull));
const vnx::TypeCode* const vnx_native_type_code_Token_get_dependency_return = vnx::get_type_code(vnx::Hash64(0x210a40139084cf5full));
const vnx::TypeCode* const vnx_native_type_code_Token_get_owner = vnx::get_type_code(vnx::Hash64(0x82e78e93b95c5f81ull));
const vnx::TypeCode* const vnx_native_type_code_Token_get_owner_return = vnx::get_type_code(vnx::Hash64(0x7bfc82d1ea6d07faull));
const vnx::TypeCode* const vnx_native_type_code_Token_get_parties = vnx::get_type_code(vnx::Hash64(0x6631733b12e41c68ull));
const vnx::TypeCode* const vnx_native_type_code_Token_get_parties_return = vnx::get_type_code(vnx::Hash64(0x434ef119eecba212ull));
const vnx::TypeCode* const vnx_native_type_code_Token_is_valid = vnx::get_type_code(vnx::Hash64(0xe2f8f3a19e55d9baull));
const vnx::TypeCode* const vnx_native_type_code_Token_is_valid_return = vnx::get_type_code(vnx::Hash64(0xdaf9a5651490bd5aull));
const vnx::TypeCode* const vnx_native_type_code_Token_transfer = vnx::get_type_code(vnx::Hash64(0xd54ee6345b881a52ull));
const vnx::TypeCode* const vnx_native_type_code_Token_transfer_return = vnx::get_type_code(vnx::Hash64(0x9e98330d476699c8ull));
const vnx::TypeCode* const vnx_native_type_code_Token_validate = vnx::get_type_code(vnx::Hash64(0xc3476057943b66ffull));
const vnx::TypeCode* const vnx_native_type_code_Token_validate_return = vnx::get_type_code(vnx::Hash64(0xc7dc19b4d86f2ca1ull));
const vnx::TypeCode* const vnx_native_type_code_WebData = vnx::get_type_code(vnx::Hash64(0xf7c226b211c088c4ull));
const vnx::TypeCode* const vnx_native_type_code_WebData_calc_cost = vnx::get_type_code(vnx::Hash64(0x3bbbd77da38a1013ull));
const vnx::TypeCode* const vnx_native_type_code_WebData_calc_cost_return = vnx::get_type_code(vnx::Hash64(0x83c6569262ee4aa5ull));
const vnx::TypeCode* const vnx_native_type_code_WebData_calc_hash = vnx::get_type_code(vnx::Hash64(0xeba91c1bc61864ecull));
const vnx::TypeCode* const vnx_native_type_code_WebData_calc_hash_return = vnx::get_type_code(vnx::Hash64(0xf8900b9ee43127d9ull));
const vnx::TypeCode* const vnx_native_type_code_WebData_is_valid = vnx::get_type_code(vnx::Hash64(0x7ae99137e8822105ull));
const vnx::TypeCode* const vnx_native_type_code_WebData_is_valid_return = vnx::get_type_code(vnx::Hash64(0x1c9f4aaa82fff87aull));
const vnx::TypeCode* const vnx_native_type_code_compare_e = vnx::get_type_code(vnx::Hash64(0xe27ffb2535efa133ull));
const vnx::TypeCode* const vnx_native_type_code_condition_e = vnx::get_type_code(vnx::Hash64(0xd11073d2e6a56dd6ull));

} // namespace mmx
} // namespace contract
