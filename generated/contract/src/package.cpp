
// AUTO GENERATED by vnxcppcodegen

#include <mmx/contract/Binary.hxx>
#include <mmx/contract/Data.hxx>
#include <mmx/contract/Executable.hxx>
#include <mmx/contract/MultiSig.hxx>
#include <mmx/contract/PubKey.hxx>
#include <mmx/contract/TokenBase.hxx>
#include <mmx/contract/VirtualPlot.hxx>
#include <mmx/contract/WebData.hxx>
#include <mmx/contract/method_t.hxx>

#include <mmx/contract/package.hxx>
#include <vnx/vnx.h>



namespace vnx {

const TypeCode* type<::mmx::contract::Binary>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Binary;
}

void type<::mmx::contract::Binary>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Binary());
}

void type<::mmx::contract::Binary>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Binary& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Data>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Data;
}

void type<::mmx::contract::Data>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Data());
}

void type<::mmx::contract::Data>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Data& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::Executable>::get_type_code() {
	return mmx::contract::vnx_native_type_code_Executable;
}

void type<::mmx::contract::Executable>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::Executable());
}

void type<::mmx::contract::Executable>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::Executable& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::MultiSig>::get_type_code() {
	return mmx::contract::vnx_native_type_code_MultiSig;
}

void type<::mmx::contract::MultiSig>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::MultiSig());
}

void type<::mmx::contract::MultiSig>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::MultiSig& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::PubKey>::get_type_code() {
	return mmx::contract::vnx_native_type_code_PubKey;
}

void type<::mmx::contract::PubKey>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::PubKey());
}

void type<::mmx::contract::PubKey>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::PubKey& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::TokenBase>::get_type_code() {
	return mmx::contract::vnx_native_type_code_TokenBase;
}

void type<::mmx::contract::TokenBase>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::TokenBase());
}

void type<::mmx::contract::TokenBase>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::TokenBase& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::VirtualPlot>::get_type_code() {
	return mmx::contract::vnx_native_type_code_VirtualPlot;
}

void type<::mmx::contract::VirtualPlot>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::VirtualPlot());
}

void type<::mmx::contract::VirtualPlot>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::VirtualPlot& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::WebData>::get_type_code() {
	return mmx::contract::vnx_native_type_code_WebData;
}

void type<::mmx::contract::WebData>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::WebData());
}

void type<::mmx::contract::WebData>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::WebData& value, bool special) {
	code.push_back(CODE_OBJECT);
}

const TypeCode* type<::mmx::contract::method_t>::get_type_code() {
	return mmx::contract::vnx_native_type_code_method_t;
}

void type<::mmx::contract::method_t>::create_dynamic_code(std::vector<uint16_t>& code) {
	create_dynamic_code(code, ::mmx::contract::method_t());
}

void type<::mmx::contract::method_t>::create_dynamic_code(std::vector<uint16_t>& code, const ::mmx::contract::method_t& value, bool special) {
	code.push_back(CODE_OBJECT);
}


} // namespace vnx


namespace mmx {
namespace contract {


void register_all_types() {
	vnx::register_type_code(::mmx::contract::Binary::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Data::static_create_type_code());
	vnx::register_type_code(::mmx::contract::Executable::static_create_type_code());
	vnx::register_type_code(::mmx::contract::MultiSig::static_create_type_code());
	vnx::register_type_code(::mmx::contract::PubKey::static_create_type_code());
	vnx::register_type_code(::mmx::contract::TokenBase::static_create_type_code());
	vnx::register_type_code(::mmx::contract::VirtualPlot::static_create_type_code());
	vnx::register_type_code(::mmx::contract::WebData::static_create_type_code());
	vnx::register_type_code(::mmx::contract::method_t::static_create_type_code());
}

static struct vnx_static_init {
	vnx_static_init() {
		register_all_types();
	}
} vnx_static_init_;

const vnx::TypeCode* const vnx_native_type_code_Binary = vnx::get_type_code(vnx::Hash64(0xbbeba47fc8b740e5ull));
const vnx::TypeCode* const vnx_native_type_code_Data = vnx::get_type_code(vnx::Hash64(0xadfeee3822244f50ull));
const vnx::TypeCode* const vnx_native_type_code_Executable = vnx::get_type_code(vnx::Hash64(0xfa6a3ac9103ebb12ull));
const vnx::TypeCode* const vnx_native_type_code_MultiSig = vnx::get_type_code(vnx::Hash64(0x7d674c5f7297dedull));
const vnx::TypeCode* const vnx_native_type_code_PubKey = vnx::get_type_code(vnx::Hash64(0x9b3cd508d7f41423ull));
const vnx::TypeCode* const vnx_native_type_code_TokenBase = vnx::get_type_code(vnx::Hash64(0x5aeed4c96d232b5eull));
const vnx::TypeCode* const vnx_native_type_code_VirtualPlot = vnx::get_type_code(vnx::Hash64(0xab02561c615511e8ull));
const vnx::TypeCode* const vnx_native_type_code_WebData = vnx::get_type_code(vnx::Hash64(0xf7c226b211c088c4ull));
const vnx::TypeCode* const vnx_native_type_code_method_t = vnx::get_type_code(vnx::Hash64(0x1f62512698176a39ull));

} // namespace mmx
} // namespace contract
